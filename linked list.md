# 연결 리스트

## 정의와 성질

### 연결 리스트의 성질

- k번째 원소를 **확인/변경**하기 위해 `O(k)`가 필요함
- 임의의 위치에 원소를 **추가**, 임의의 위추의 원소 **제거**는 `O(1)`
- 원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움

### 연결 리스트의 종류

- 단일 연결 리스트 <sup>Singly Linked List</sup>
  - 각 원소가 다음 원소의 주소를 가지고 있음
- 이중 연결 리스트 <sup>Doubly Linked List</sup>
  - 각 원소가 자신의 이전 원소와 다음 원소의 주소를 둘 다 들고 있음
  - 단일 연결 리스트에서는 주어진 원소의 **이전 원소가 무엇인지**를 알 수 없지만 이중 연결 리스트에서는 알 수 있음
  - 다만 원소가 가지고 있어야 하는 정보가 1개 더 추가되니 **메모리를 더 쓴다는 단점**이 있음
  - 참고로 STL에 연결 리스트가 있는데, 이 컨테이너의 이름은 list이고 구조는 이중 연결 리스트
- 원형 연결 리스트 <sup>Circular Linked List</sup>
  - 끝이 처음과 연결되어 있음

### 배열 vs 연결 리스트

|                                            | 배열  | 연결 리스트 |
| :----------------------------------------: | :---: | :---------: |
|             k번째 원소의 접근              | O(1)  |    O(k)     |
|         임의 위치에 원소 추가/제거         | O(N)  |    O(1)     |
|              메모리 상의 배치              | 연속  |   불연속    |
| 추가적으로 필요한 공간 <sup>overhead</sup> |   -   |    O(N)     |

- 추가적으로 필요한 공간, 즉 overhead를 생각해보면 배열은 데이터만 저장하면 될 뿐 딱히 추가적으로 필요한 공간이 없음.
- 굳이 따지면 길이 정보를 저장할 int 1개가 필요할 수 있지만 이건 너무 미미하니 신경을 쓸 필요가 없을 정도.
- 그러나 연결 리스트에서는 각 원소가 다음 원소, 혹은 이전과 다음 원소의 주소값을 가지고 있어야 함.
- 32비트 컴퓨터면 주소값이 32비트(=4바이트) 단위이니 4N 바이트가 추가로 필요하고, 64비트 컴퓨터라면 주소값이 64비트(=8바이트) 단위이니 8N 바이트가 추가로 필요하게 됨. 즉 N에 비례하는 만큼의 메모리를 추가로 쓰게 된다.

## 기능과 구현

## STL list

## 연습 문제
